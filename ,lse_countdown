#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "pytz>=2025.1",
# ]
# ///

import datetime
import time
from datetime import date
from itertools import cycle

import pytz


def get_next_trading_day(start_date, holidays):
    next_day = start_date + datetime.timedelta(days=1)
    while True:
        if next_day.weekday() < 5 and next_day not in holidays:
            return next_day
        next_day += datetime.timedelta(days=1)


def format_timedelta(delta):
    total_seconds = int(delta.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"


def get_lse_status():
    # Trading hours configuration
    start_time = datetime.time(8, 0)
    end_time = datetime.time(16, 30)

    # https://www.londonstockexchange.com/equities-trading/business-days
    lse_holidays = {
        date(2025, 4, 18),
        date(2025, 4, 21),
        date(2025, 5, 5),
        date(2025, 5, 26),
        date(2025, 8, 25),
        date(2025, 12, 25),
        date(2025, 12, 26),
        date(2026, 1, 1),
        date(2026, 4, 3),
        date(2026, 4, 6),
        date(2026, 5, 4),
        date(2026, 5, 25),
        date(2026, 8, 31),
        date(2026, 12, 25),
        date(2026, 12, 28),
        date(2027, 1, 1),
    }

    lse_half_days = {
        date(2025, 12, 24),
        date(2025, 12, 31),
        date(2026, 12, 24),
        date(2026, 12, 31),
    }

    tz_london = pytz.timezone("Europe/London")
    london_time = datetime.datetime.now(tz_london)
    current_time = london_time.time()
    current_date = london_time.date()

    if current_date > max(lse_holidays | lse_half_days):
        raise ValueError("LSE trading holiday list is not up-to-date.")

    # Determine market status
    if current_date in lse_holidays or london_time.weekday() >= 5:
        is_open = False
    elif current_date in lse_half_days:
        is_open = start_time <= current_time <= datetime.time(12, 30)
    else:
        is_open = start_time <= current_time <= end_time

    # Calculate next event time
    if is_open:
        event_time = datetime.datetime.combine(current_date, end_time)
    elif current_date.weekday() < 5 and current_date not in lse_holidays:
        if current_time < start_time:
            event_time = datetime.datetime.combine(current_date, start_time)
        else:
            next_day = get_next_trading_day(current_date, lse_holidays)
            event_time = datetime.datetime.combine(next_day, start_time)
    else:
        next_day = get_next_trading_day(current_date, lse_holidays)
        event_time = datetime.datetime.combine(next_day, start_time)

    event_time = tz_london.localize(event_time)
    return is_open, event_time


def main():
    spinner = cycle(reversed(["â£¾", "â£½", "â£»", "â¢¿", "â¡¿", "â£Ÿ", "â£¯", "â£·"]))
    try:
        while True:
            # Hide cursor
            # Show cursor with print('\033[?25h', end="")
            print('\033[?25l', end="")
            is_open, next_event = get_lse_status()
            now = datetime.datetime.now(pytz.timezone("Europe/London"))
            remaining = next_event - now

            if remaining.total_seconds() > 0:
                countdown = format_timedelta(remaining)
                status = "OPEN ðŸŸ¢" if is_open else "CLOSED ðŸŸ "
                action = "Closes" if is_open else "Opens"
                spinner_char = next(spinner)

                print(
                    f"LSE {status} | {action} in {countdown} {spinner_char}\r",
                    end="",
                    flush=True,
                )
            else:
                # Force status refresh when crossing threshold
                time.sleep(0.1)
                continue

            time.sleep(1)

    except KeyboardInterrupt:
        print("\nCountdown stopped.")


if __name__ == "__main__":
    main()
