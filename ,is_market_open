#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "pytz>=2025.1",
#     "blessed>=1.20.0",
# ]
# ///

import datetime
import time
from datetime import date
from functools import cache
from itertools import cycle

import pytz
from blessed import Terminal


@cache
def get_next_trading_day(start_date, holidays):
    next_day = start_date + datetime.timedelta(days=1)
    while True:
        if next_day.weekday() < 5 and next_day not in holidays:
            return next_day
        next_day += datetime.timedelta(days=1)


@cache
def format_timedelta(delta):
    total_seconds = int(delta.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"


def get_lse_info():
    timezone = pytz.timezone("Europe/London")
    return (
        "LSE",
        timezone,
        datetime.time(8, 0),
        datetime.time(16, 30),
        datetime.time(12, 30),
        {
            date(2025, 4, 18),
            date(2025, 4, 21),
            date(2025, 5, 5),
            date(2025, 5, 26),
            date(2025, 8, 25),
            date(2025, 12, 25),
            date(2025, 12, 26),
            date(2026, 1, 1),
            date(2026, 4, 3),
            date(2026, 4, 6),
            date(2026, 5, 4),
            date(2026, 5, 25),
            date(2026, 8, 31),
            date(2026, 12, 25),
            date(2026, 12, 28),
            date(2027, 1, 1),
        },
        {
            date(2025, 12, 24),
            date(2025, 12, 31),
            date(2026, 12, 24),
            date(2026, 12, 31),
        },
    )


def get_nyse_info():
    timezone = pytz.timezone("America/New_York")
    return (
        "NYSE",
        timezone,
        datetime.time(9, 30),
        datetime.time(16, 0),
        datetime.time(13, 00),
        {
            date(2025, 1, 1),
            date(2025, 1, 20),
            date(2025, 2, 17),
            date(2025, 4, 18),
            date(2025, 5, 26),
            date(2025, 6, 19),
            date(2025, 7, 4),
            date(2025, 9, 1),
            date(2025, 11, 27),
            date(2025, 12, 25),
            date(2026, 1, 1),
            date(2026, 1, 19),
            date(2026, 2, 16),
            date(2026, 4, 3),
            date(2026, 5, 25),
            date(2026, 6, 19),
            date(2026, 7, 3),
            date(2026, 9, 7),
            date(2026, 11, 26),
            date(2026, 12, 25),
            date(2027, 1, 1),
            date(2027, 1, 18),
            date(2027, 2, 15),
            date(2027, 3, 26),
            date(2027, 5, 31),
            date(2027, 6, 18),
            date(2027, 7, 5),
            date(2027, 9, 6),
            date(2027, 11, 25),
            date(2027, 12, 24),
        },
        {
            date(2025, 7, 3),
            date(2025, 11, 28),
            date(2025, 12, 24),
            date(2026, 11, 27),
            date(2026, 12, 24),
            date(2027, 11, 26),
        },
    )


def get_market_status(market_info):
    (
        market_name,
        timezone,
        start_time,
        end_time,
        half_day_end_time,
        holidays,
        half_days,
    ) = market_info

    local_time = datetime.datetime.now(timezone)
    current_time = local_time.time()
    current_date = local_time.date()

    if current_date > max(holidays | half_days):
        msg = f"{market_name} holiday list is not up-to-date."
        raise ValueError(msg)
    if holidays & half_days:
        msg = f"{market_name} has overlapping holidays/half-days"
        raise ValueError(msg)

    if current_date in holidays or local_time.weekday() >= 5:
        is_open = False
    elif current_date in half_days:
        is_open = start_time <= current_time <= half_day_end_time
    else:
        is_open = start_time <= current_time <= end_time

    if is_open:
        event_time = timezone.localize(
            datetime.datetime.combine(current_date, end_time)
        )
    elif (
        current_date.weekday() < 5
        and current_date not in holidays
        and current_time < start_time
    ):
        event_time = timezone.localize(
            datetime.datetime.combine(current_date, start_time)
        )
    else:
        next_day = get_next_trading_day(current_date, tuple(holidays))
        event_time = timezone.localize(
            datetime.datetime.combine(next_day, start_time)
        )

    return is_open, event_time


def main():
    term = Terminal()
    spinner = cycle("ðŸ•›ðŸ•§ðŸ•ðŸ•œðŸ•‘ðŸ•ðŸ•’ðŸ•žðŸ•“ðŸ•ŸðŸ•”ðŸ• ðŸ••ðŸ•¡ðŸ•–ðŸ•¢ðŸ•—ðŸ•£ðŸ•˜ðŸ•¤ðŸ•™ðŸ•¥ðŸ•šðŸ•¦")
    lse_info = get_lse_info()
    nyse_info = get_nyse_info()

    with term.fullscreen(), term.hidden_cursor():
        try:
            while True:
                # Get market statuses
                is_lse_open, lse_event = get_market_status(lse_info)
                is_nyse_open, nyse_event = get_market_status(nyse_info)
                spinner_char = next(spinner)

                # Build display lines
                lse_line = (
                    f"{lse_info[0].rjust(6)} "
                    f"{'OPEN ðŸŸ¢' if is_lse_open else 'CLOSED ðŸŸ '} | "
                    f"{'Closes' if is_lse_open else 'Opens'} in "
                    f"{format_timedelta(lse_event - datetime.datetime.now(lse_info[1]))} "
                    f"{spinner_char}"
                )

                nyse_line = (
                    f"{nyse_info[0].rjust(6)} "
                    f"{'OPEN ðŸŸ¢' if is_nyse_open else 'CLOSED ðŸŸ '} | "
                    f"{'Closes' if is_nyse_open else 'Opens'} in "
                    f"{format_timedelta(nyse_event - datetime.datetime.now(nyse_info[1]))} "
                    f"{spinner_char}"
                )

                # Update display
                print(term.move(0, 0) + term.clear_eos + lse_line + "\n" + nyse_line)
                time.sleep(1)

        except KeyboardInterrupt:
            print(term.move_down(2) + "Countdown stopped.")


if __name__ == "__main__":
    main()
